# java 的内存模型  
java memory model    

> ![详情链接](http://ifeve.com/java-memory-model-0/)

高速缓存解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性(Cache coherence).  

> JMM  解决可见性的问题（同步包括独占性和可见性）  


**java 内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量。**  
同时定义了线程和主内存之间的抽象关系.  

* JMM通过控制主内存与每个线程的本地内存之间的交互, 提供了内存可见性保证。  
 
* Java线程间的通信由JMM控制  
	
	JMM决定一个线程对共享变量的写入何时对另一个线程可见  

* Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（与cache类比）  

	线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写内存中的变量。  

	Java 线程 <-----> 工作内存 <------> sava和`load`操作 <-----> 主内存  


### 主内存和工作内存之间的具体交互协议  
Java 内存模型定义了一下八种操作：  

1. lock ： 		----> 主内存变量， 把一个变量标识为一条线程独占状态  
2. Unlock ：		----> 主内存变量， 释放  
3. read :  		----> 主内存变量， 把一个变量值从内存传送到线程的工作内存 ，便于load 操作  
4. load : 		----> 工作内存的变量，把read的变量值放入到工作内存的变量副本中  
5. use ：		----> 工作内存的变量，工作内存的变量值--> 执行引擎  
6. assign : 	----> 工作内存的变量, 把从执行引擎得到的值----> 赋给工作内存的变量  
7. store ： 		----> 工作内存的变量, 传给主内存，便于后面的write操作  
8. write :		----> 主内存的变量，把从工作内存的传过来的变量进行write进主内存  


Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行  


### happens-before 原则  
* 程序顺序规则  
* 监视器规则
* volatile变量原则
* 传递性  




### 重排序  

源代码----> 编译器优化重排序 ----> 指令级并行重排序 -----> 内存系统重排序 ----> 最终执行的指令序列  

为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序  

重排序可能会导致多线程程序出现内存可见性问题，   
> Java内存模型JMM 确保在不同的编辑器和不同的处理器平台上，通过禁止特定的的编译器重排序和处理器重排序，  
> 为程序员提供一致的内存可见性。  




Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：  

![](http://images.cnitblog.com/i/475287/201403/091516513623330.png)    

### 数据依赖性  
编译器和处理器在重排序时，会遵守数据依赖性。  
> 数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑  

### as-if-serial 语义  
不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。  
编译器，runtime 和处理器都必须遵守as-if-serial语义.  
  
### 程序顺序规则  
JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前  

JMM允许不影响操作结果的重排序  

### 重排序对多线程的影响  
多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  

### 数据竞争与顺序一致性保证  
当程序未正确同步时，就会存在数据竞争  

在Java内存模型对数据竞争的定义如下：  
1. 在一个线程中写一个变量  
2. 在另一个线程中读同一个变量  
3. 写和读没有通过同步来排序  


* 如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序  
	正确同步的多线程程序  

* 如果程序是正确同步的，则程序的执行将具有顺序一致性  

### 顺序一致性内存模型    
与Java 内存模型不同    
特性：  
* 一个线程中的所有操作必须按照程序的顺序来执行  
* （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序  
* 在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。  


### 同步机制 ：   

**volatile , synchronized, final**  
  
1. 线程内存访问机制  
	
2. volatile 关键字  
	
	用`volatile`修饰的变量，线程在每次使用变量的时候，都会读取修改后的最新的值.  
	对变量的写操作，不依赖于当前值  
	不能和其他变量同时出现在一个表达式中    
	volatile的作用就是使它修饰的变量的读写操作都必须在内存中进行

	* 线程A写一个volatile变量， 实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息  
	* 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息  
	* 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息  


	
3. synchronized关键字 
	
	线程同步的内部机制，通过加锁的方式保证线程的可见性和互斥性，  
	即一个线程的执行结果可以被另一个线程所看到且在同一时间只能有一个线程执行被保护的代码块  

**volatile与synchronized**    

1. volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取。  
2. synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.  
3. volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.  
4. volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性  
5. volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.  
6. volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.  

 

### Java最大线程数  

(MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize) = Number of threads  

MaxProcessMemory 指的是一个进程的最大内存  

JVMMemory         JVM内存  

ReservedOsMemory  保留的操作系统内存  

ThreadStackSize      线程栈的大小  

